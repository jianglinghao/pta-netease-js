# 错题备忘录

## easy

- 7-3 首次提交 以为只要往右和往下搜索即可，没有考虑到特殊 第一层中间隔了一个，第二层又向上连通的 case。

```
console.log(countMountain([
  [1,1,0,0,0],
  [1,1,0,0,0],
  [0,0,1,0,1],
  [0,1,1,1,1],
], 4, 5))
```

- easy: 7-6 首次提交 忽略了不同字符不能映射到同一个字符上的 case。
- easy: 7-8 被这个用例卡了一上午: YazaAay 。首次解法，先通过 z 分割成两个子串后，只判断了 aAay 子串，没有判断 aAa 子串。最后是用了分治递归思想。
- easy: 7-9 n=0 时要返回 -1
- easy: 7-10 尽管 [LeetCode 一样的题目](https://leetcode.cn/problems/validate-binary-search-tree/submissions/496891943/)，可以完全通过，但 pta 只能拿 27 分，不知道是什么特殊 case. (最终发现是构建树的方式，不能按照满二叉树遍历的顺序构建，而是按层序遍历的方式)
- easy: 7-15 首次提交使用回溯解法，遗漏了比较 当前最小值 与 缓存最小值的比较，直接返回了缓存值。该解法会超时，最后还是要用 dp 实现。
- easy: 7-16 首次提交遗漏了 00:00 的输出格式，输出成了 0:0

## medium

- medium: 7-5 首次提交使用回溯 O(n^3)复杂度，无法通过全部用例。改为空间换时间后，O(n^2) 复杂度，通过全部用例。
- medium: 7-6 首次调试时未考虑到全负数情况下，单个数字 8 和 89 及 9 和 99 两个 case 的第二位比较情况。
- medium: 7-7 第一版只能拿 21 分。改用并查集解法后首次只能拿 9 分(leetCode 原题能拿满分)，处理输入的空行后，可拿满分。

## hard

- hard: 7-1 首次提交时只能拿 0 分，原因是没有考虑到，输入的 listData 中可能会存在非两个链表中的地址!!!!
- hard: 7-2 首次提交部分超时。后面将求公约数算法改为欧几里得求最大公约数算法后，可拿满分。
- hard: 7-3 第一版回溯解法超时 12/60 分，第二版查找最大值只能拿 48/60 分。第三版是用单调栈解法,可拿满分。
- hard: 7-4 首次提交时忘记了是严格递增子序列(即相等时不能继续放入队列)
- hard: 7-5 首次提交理解错了题目的含义(没有理解一个节点只能被计算一次，故而求了最大子树和)。
- hard: 7-6 首次提交时将 acc 作为 search 的参数携带，会导致回溯后，值减少。应作为全局变量提交。
- hard: 7-7 首次提交时使用了回溯算法，但由于找不到剪枝条件，会在一个用例上超时。改为 dp 算法后可通过。
- hard: 7-8 首次提交的暴力解法，时间复杂度无法满足(且对于数字 1 的解码会出错)。参考 leetCode 题解后可通过。
- hard: 7-9 暴力解法可通过，leetCode 题解更妙。
- hard: 7-10 暴力解法也可通过，leetCode 题解更妙。
- hard: 7-12 暴力解法只能拿 48/60 分。通过分析暴力解法输出的回文因子发现回文因子每一位不超过 2，通过排列组合可穷举出所有的回文因子。注意 20 位回文数字，需要使用 BigInt 数据结构，防止溢出。
- hard: 7-13 首次提交未考虑到此 case '0 3 0 3 2'，会错误地划分为 [0] [3 0] [3 2] 3 块。后在 leetCode 查看到此错误用例后，才更正思路。
- hard: 7-14 首次提交遗漏了多行输入的空行过滤 & 遗漏了对 ABA 字符串必定需要包含字母的判断
